<!DOCTYPE html>
<html>
    <head>
        <script>
            //배열 변수 선언
            let arr = [];
            //클래스 선언
            let arr2 = new Array();

            arr = [1,"글씨", 3];
            arr2 = (1,4,5);

            console.log(`arr[0] : `, arr[0]);
            arr[0] = 10;
            console.log(`arr[0] : `, arr[0]);

            console.log(arr);
            console.log("arr :" + arr );
            console.log("arr :" + arr );

            arr[10] = 10;
            console.log("arr : ", arr);
            console.log("arr[20] : ", arr[20]);

            //인덱스의 경우 변수가 올수도 있다.
            //이 경우 배열의 길이에 영향을 주지 않는다.
            arr["name"] = "민수";
            console.log("arr : ", arr);
            console.log("arr['name'] : ", arr["name"]);

            console.log(arr.length);

            const str = "휴먼교육센터";
            console.log(str[0]);

            for (let i = 0; i<str.length;i++){
                console.log(str[i]);
            }

            //이중배열
            let sports = [`basketball`, `soccer`, `tennis`];
            let fight = [`boxing`, 'taegundo', `sword`];
            let ice = [`figure`, `skate`, `board`,`ski`];
            let action = [sports, fight, ice];

            for (let i = 0; i < action.length; i++){
                for(let j = 0; j<action[i].length; j++){
                    console.log(action[i][j]);
                }
            }

            arr = [1,2,3,4];
            arr[4] = 5;
            console.log(arr[5]);
            //arraylist처럼 메소드 사용하기
            arr.push(5); //이어 붙히기
            console.log(arr);

            //앞에 하나 추가
            arr.unshift(0);
            console.log(arr);

            //그냥 shift는 맨 처음것 하나를 return, 원본이 바뀜(파괴함수)
            let shift = arr.shift();
            console.log(arr);
            console.log(`shift`, shift);
            console.log(arr);

            //맨끝에 있는 것 하나를 return,파괴 함수
            let pop = arr.pop();
            console.log(arr);
            console.log(`pop` , pop);

            //arr을 뒤집어줌
            arr.reverse(); //마찬가지로 파괴함수
            console.log(arr);
            
            arr = [1,54,84,22,6,4,8,41,6,1,6]; //기본적으로 문자열로 취급한다.
            const ar = [1,54,84,22,6,4,8,41,6,1,6]; 
            //const는 재선언이 불가능 하게 막기만 할뿐  배열 안의 순서라던가 연산 자체를 막지는 않는다.
            

            // arr.sort() //내림차순 정렬
            // console.log(arr);

            ar.sort(function(x,y){
                return y-x //음수면 x가 크다는 이야기

            }); //역순으로 정렬 하는법, 순차적 이론을 확인해보자, 작동순서
            console.log(ar);
            
            ar.sort(function(x,y){
                return x-y //음수면 y가 크다는 이야기

            }); //정순으로 정렬 하는법, 순차적 이론을 확인해보자, 작동순서

            //sort한다음 reverse하면 될듯
            console.log(ar);

            //js의 변수는 전부다 1등 객체. first class object , 변수는 어떤것도 담을수 있다. 
            //typeof : 변수의 타입 확인
            


            //////////////////////////////////호이스팅//////////////////////////////////////////////
            //a를 정의 하지 않으면 너무 많은 호이스팅이 발생해서 전역변수로 됨
            //소스를 인터프리터로 전달할때 한번 정리가 발생한다.
            //그때 var는 함수의 최 상단으로 올라간다. 아무것도 쓰지 않는 변수는 파일의 최상단으로 올라간다.

            // console.log(f);
            // let f = 10; undefine error가 아닌 다른 에러가 출력 되는데 이는 일종의 스포일러, 어딘가에 선언되 있긴 하지만 아직은 아니다 라는 의미



            function test(){
                var a = 10;
                console.log(a);
                function rest(){
                    console.log(a);
                    if(3<5){
                        console.log(a);
                    }
                    console.log(a);
                }
                rest();
            }
            //var의 경우 function안에서 사용 가능하니까 아래 함수에서도 사용할수 있다,let도 마찬가지

            var a = 10
               function test(){
                    var a = 30;
                    
                    console.log(a);
                    rest();
                }
                //전역변수 보다 지역 변수가 힘이 좀더 센거 같다,

               function rest(){
                    console.log(a);
                    if(3<5){
                        console.log(a);
                    }
                    console.log(a);
                }

                //이러면 실행이 되지 않는다. a는 test함수의 지역변수 이기에 rest함수는 a의 정채를 밝힐수 없다 .

                // var a = 10 이 먼저 실행된뒤 a가 선언되면 나중에 선언이 된 것을 기준으로 정해진다.

                arr = [0,1,2,3,4,5];
                let s = arr.splice(2,3);
                console.log(s);

                let i = 0;
                for (let obj of arr){
                    console.log("obj" , obj,i++);
                }
                
                let array = [];
                // array[2] = ['1,1'];
                // array[3] = ['1,2'];
                // array[4] = ['1,3','2,2'];
                // array[5] = ['4,1','3,2'];
                // array[6] = ['5,1','4,2','3,3'];
                // array[7] = ['6,1', '5,2','4,3']
                // array[8] = ['6,2','5,3','4,4'];
                // array[9] = ['6,3','5,4'];
                // array[10] = ['6,4','5,5'];
                // array[11] = ['5,6'];
                // array[12] = ['6,6'];
                
                const array_1 = [];
                for (let x = 2; x <=12; x++){                    
                    array_1[x] = [];
                    let n = 0;
                    for (let y = 6;y>0;y--){
                        
                        if(x-y<=6){
                                                            
                            if(x-y >=y){
                                //for문마다 새로운 블럭 스코프에 선언이 되는것이기 떄문에 
                                // 반복해서 선언할수 없는 const의 특성이 상관이 없다. 
                                // 새로운 공간마다 선언하는 것이기 떄문이다/
                                const pairStr = "[" + (x - y) + "," + y + "]";
                                array_1[x].push(pairStr);                         
                                n++;
                                // array_1[x].push("[" + (x-y) +"," + y+ "]"); 
                                // 왜 이건 안되지?? 해결
                                // console.log("[" + (x-y) +"," + y+ "]")
                                // console.log(array_1[x]);                                                   
                            }                    
                        }
                    }
                    console.log("{x = "+x+"}" + array_1[x] +"                   "+n);                    
                }

                if(array[4] == undefined){
                    console.log(array[4])
                }

                array[4] +='abc'; //undefine 에러 구문 자체를 문자로 인식함
                console.log(array[4])


                function log(...obj){
                    console.log(typeof obj); // 유사배열
                    console.log(typeof obj[1]); // 유사배열 , 두번째것 출력
                    console.log(obj); //배열의 타입 = obj


                }

                let f = [10,20];
                console.log(...f);
                console.log(f[0], f[1]);


                let g = "console.log(123)";
                eval(g); //문자열 안에 있는 수식이나 구문을 실행하게 해줌

                // let p2 = print();
                // console.log(typeof p2);
                // console.log(typeof print());

                function print2(){
                    console.log("print2 실행");
                }
                function print2(){
                    console.log("print3 실행");
                }
                print2();

                //함수명이나 변수 명이 같다면 덮어쓰기가 된다.

                function over(x){
                    console.log("x:", x);
                }
                function over(x,y){
                    console.log("x:", x,"y:" ,y);
                }
                over(1);
                console.log(typeof over);

                over = 1;
                console.log(typeof over);
                
                // 1달러 기준 환율
                const exchangeRate = 1354.75;

                // 달러 → 원 환전 함수
                function change_en_ko(dollar) {
                    if (typeof dollar !== 'number') {
                        console.log("올바른 숫자를 입력해주세요.");
                        return null;
                    }
                    return dollar * exchangeRate;
                }

                // 원 → 달러 환전 함수
                function change_ko_en(won) {
                    if (typeof won !== 'number') {
                        console.log("올바른 숫자를 입력해주세요.");
                        return null;
                    }
                    return won / exchangeRate;
                }

                // 환전 함수: 금액과 콜백함수(환율 계산 방식)를 받아 처리
                function change(money, callback) {
                    if (typeof callback === 'function') {
                        console.log("환전을 시작합니다.");
                        const result = callback(money);
                        return result;
                    } else {
                        console.log("콜백함수가 유효하지 않습니다.");
                        return null;
                    }
                }

                // 테스트 실행
                const moneyInWon = change(100, change_en_ko);
                console.log(`환전된 금액은 ${moneyInWon}원입니다.`);

                const moneyInDollar = change(135475, change_ko_en);
                console.log(`환전된 금액은 ${moneyInDollar}달러입니다.`);

                const m = 100;
                let noName = function(){
                    console.log(`익명함수`);
                }
                noName();

                
                change(m, noName);
                change(100, function (){
                    console.log(`익명함수`);
                });

                
                console.log(`--------------------------`);


                //첫번떄 전달인자: 실행할 함수(콜백함수)
                // 두번째 전달인자 : 지연시간(1/1000초)
                // setTime(noName , 1000 * 3)
                setTimeout(function(){
                    console.log(`3초뒤 실행됨`);
                }, 1000*3
            );

            // clearTimeout :settime을 취소하는 기능

            si = setInterval(function(){
                console.log(" fsfsf");
                
            },1000*2);

            //3초후 실행됨 이후에 fsfsf가 바로 실행된다. 3초후 실행은 읽고 나서 3초후 에 출력이 되는데, 
            // fsff는 2초후 실행되기 때문에 먼저 출력된다.
            setTimeout(function(){
                clearInterval(si);
                console.log("end");
            }, 5000)

            //화살표 함수
            //익명함수의 경우일때만 활용 가능 , 함수로 변경할수있다.

            let text0 = function(a,b){
                console.log(a,b);
                return a;
            }

            let text1 = (a,b) =>{
                console.log(a,b);
                return a;
            }


            //전달인자가 하나 일때만 전달인자의 괄호를 생략할수 있다.
            let  text2 = a => {
                console.log(a,b);
                return a;
            }

            //전달인자가 없을떄, 괄호 생략 불가능
            let text4 =() =>{

            }


            //실행문 안에 return문만 이있는경우 return과 중괄호  생략가능
            let text5 = (a,b) => a+b;

            let text6 = a => a*3;
            console.log(text6(76));

            arr.sort((x,y) => y-x); //function생략, return생략
            console.log(arr);

            const arr3 = ["a", "b","c","d"];

            //forEach(element, index,array)
            let r1 = arr3.forEach(
                //return 없음
                function(a,b,c,d){
                    console.log("-----------------------------------")
                    // console.log(a,b,c,d);
                    console.log("a = ", a);
                    console.log("b = ", b);
                    console.log("c = ", c);
                    console.log("d = ", d);
                }
            );
            console.log(r1);

            const movies = [
                `노이즈`,`더 무비`,`드래곤 길들이기`
                ,`쥬라기 월드 : 새로운 시작`,`그을린 사랑`
            ]
            
            
            //forEach : 각 항목별로 함수를 실행
            //함수의 전달인자 : 현제값, 현제 index, 전체 배열
            //return 없음

            //map 각 항목별로 하나하나 실행해서 return값으로 새로운 배열을 반환한다.
            
            let len3 = movies.map(function(el, i, arr){
                console.log(`elememt : `, el);
                console.log(`index : `, i);
                console.log(`array : `, arr);
                console.log(`---------------------------------`)
                return el.length;
            })
            let len = movies.map(e1 => e1.length);
            console.log(`len` , len);

            let filtered = movies.filter( function(element,index,array){
                    console.log("-----------------------------------")
                    // console.log(a,b,c,d);
                    console.log("a = ", element);
                    console.log("b = ", index);
                    console.log("c = ", array);

                    let len = element.legth;
                    // if(len >4){
                    //     return true;
                    // } else {
                    //     return false;
                    // }

                    return element.length > 4;

                    
                }

            );
            console.log(filtered);

            
            let filtered2 = movies.filter(e => e.length > 4);
            console.log("filtered2 = ", filtered2);

            

            



                




            </script>
        </head>
    </html>